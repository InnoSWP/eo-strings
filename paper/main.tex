\documentclass[11pt,nonacm,natbib=false]{acmart}
\settopmatter{printfolios=false,printccs=false,printacmref=false}
\usepackage[utf8]{inputenc}
\usepackage{paralist}
\usepackage{ffcode}
\usepackage{authblk}
\usepackage{calc}
\usepackage{ifthen}
\usepackage{tikz}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}


\title{Methods Necessary for String Classes in Object-Oriented Programming Languages}
\author{
Timolai Andrievich, 
 Aksinya Kochunova, 
 Egor Zavrazhnov, \\
 Kseniya Sicheva, 
 Anel Salkenova, 
 Irina Schetinina 
}

\date{7 June 2022}

\affil{Innopolis University}

\begin{document}

\maketitle

\section{Introduction}
In programming, a string is a primitive type designed to provide an interface for an ordered set of characters. However, standard library implementations of this interface vary in different languages. Thus, it is clear that the programming community has not decided on the optimal implementation of a string class. Therefore, this paper aims to determine a minimalistic set of string functions sufficient for a string class.

\section{Set Building}
\subsection{Necessary and Sufficient Functions}
One of the ways to select necessary and sufficient set of methods is to select methods that are sufficient and necessary to build a Turing machine. The Turing machine is the automaton with the highest computational capability, thus, any program that can be implemented can be implemented through selected methods. The memory tape of the Turing machine can be represented as three strings: parts of the memory tape right and left from the pointer and the memory cell with the pointer. Three operations are necessary for a Turing machine: \begin{inparaenum}
 \item move the head to the left, 
 \item move the head to the right, and 
 \item write a symbol to the cell.
 \end{inparaenum}
 Therefore, assuming that assignment operations and user interactions are handled by other aspects of programming language, the following methods are necessary:
\begin{enumerate}
    \item \ff{concatenate}---concatenate two strings
    \item \ff{slice}---returns the substring of requested length, starting at a given position as a string
    \item \ff{length}---returns the length of the string
\end{enumerate}
If \ff{left\_side} is part of the tape left to the head, \ff{right\_side} is part of the tape right to the head, \ff{cell} is the cell tape with the head on it.
Turing machine operations can be implemented as follows: 
\begin{enumerate}
\item Move the head to the left: 
\begin{ffcode}
right_side := cell.concatenate(right_part);
cell := left_side.slice(left_side.length() - 1, 1);
left_size := left_side.slice(0, left_side.length() - 1);
\end{ffcode}
\item Move the head to the right: 
\begin{ffcode}
left := left_side.concatenate(cell);
cell := right_side.slice(0, 1);
right_side := right_side.slice(1, right_side.length() - 1);
\end{ffcode}
\item Write a symbol to the cell: 
\begin{ffcode}
cell := symbol;
\end{ffcode}
\end{enumerate}
Therefore, all computable algorithms, including string-related algorithms, can be described through strings using these three methods.
\subsection{Populating the Set}
However, such an approach is not practical, and other methods need to be  included. For this purpose, the following criteria for selection and algorithm for set construction are proposed:
\subsubsection{Criteria}
\begin{enumerate}
    \item Can not be implemented in three or fewer instructions using functions already in set
    \item Can be implemented in the least amount of instructions among all remaining functions
\end{enumerate}
\subsubsection{Algorithm}
\begin{enumerate}
    \item Functions \ff{slice}, \ff{length}, and \ff{concatenate} are added to the set
    \item The function that falls under all criteria in 2.2.1 is added to the set
    \item The second step is repeated until no fitting functions remain
    \item Then, the set is hedged by deleting functions that do not fit requirements outlined in step two
\end{enumerate}
\subsection{Analysis of the final selected functions}
After executing the algorithm, following functions were selected:
\begin{enumerate}
    \item \ff{concatenate}---concatenates two strings
    \item \ff{length}---returns the length of the string
    \item \ff{slice}---returns substring specified by arguments
    \item \ff{compare}---compares two strings
    \item \ff{capitalize}---converts the first character to the uppercase, and all other to the lowercase
    \item \ff{hash}---returns the hash of the string
    \item \ff{is-alphabetic}---checks if the string contains only letters
    \item \ff{is-lowercase}---checks if the string contains only lowercase letters
    \item \ff{swap-case}---converts all lowercase characters to uppercase, and vise versa
    \item \ff{sscanf}---scans the string according to format strings and returns resulting values
    \item \ff{sprintf}---given the format string and a set of values, returns formetted output
\end{enumerate}

\subsection{Functions in Other Languages}
The team analyzed the libraries of several languages: Ruby, C++, Java, and Python. AS the purpose of this paper is to create a set of functions for the standard library, none of the third-party libraries for string operations, such as Boost for C++ were not analyzed.
The data was collected from GitHub using advanced search among all the repositories and compiled into a list of the most popular functions for each language.
In C++, the selected functions cover 76\% of the uses of functions with strings in general. 
In Python this number is 44\%, Ruby - 33\%, Java - 38\%. 
The small percentage in the last three languages can be explained by a large number of redundant functions in that language. 
The most complete string libraries are the Java and Python ones. The C++ library is the most minimalistic one. 
This could be due to the age of C++, as the language appeared at 1985, almost 10 years earlier than other three. It lacks some common functions, but has a few unapplicable to high-level languages, mostly memory-related. 
For example, capacity - this function for strings is not available in Java, Python or Ruby. 
Ruby has the most balanced library, with many features but almost no duplicate functions
as in Java.
The collected data can be used to estimate the importance of a function from the frequency of its use by other programmers. This estimate may help improve the ease of use of the set of functions selected in 2.2. The analysis of a few of the functions, not included in the set can be found in \emph{\autoref{tab:excluded_functions}}

\begin{table}
\begin{tabular}{l | l | p{265pt}}
Function name & Libraries          & Reasons of excluding                                                                                                                      \\
capacity      & C++                & Presented only in one library, has limited functionality, used only in 0,02\% of general string functions usage                           \\
fill-letft    & Ruby               & Presented only in one library, can be implemented in three or fewer instructions, used only in 0,002\% of general string functions usage  \\
fill-right    & Ruby               & Presented only in one library, can be implemented in three or fewer instructions, used only in 0,002\% of general string functions usage  \\
is-title      & Python             & Presented only in one library, can be implemented in three or fewer instructions, used only in 0,0001\% of general string functions usage \\
repeat        & Java, Python       & Presented only in 2 libraries, can be implemented in three or fewer instructions, used only in 0,002\% of general string functions usage  \\
patrition     & Python, Ruby       & Presented only in 2 libraries, used only in 0,003\% of general string functions usage                                                     \\
shrink-to-fit & C++                & Presented only in one library, has limited functionality, used only in 0,003\% of general string functions usage                          \\
strip         & Java, Python, Ruby & Can be implemented in three or fewer instructions, used only in 0,015\% of general string functions usage                                 \\
starts-with   & Java, Python, Ruby & Can be implemented in three or fewer instructions, used only in 0,01\% of general string functions usage                                 
\end{tabular}
\caption{\label{tab:excluded_functions}Analysis of the sample of the functions not included in the set.}
\end{table}

\section{Conclusion}
After analyzing the selection of functions, several were selected: \ff{concatenate}, \ff{slice}, \ff{compare}, \ff{capitalize}, \ff{format}, \ff{hash}, \ff{is-alphabetic}, \ff{is-lowercase}, \ff{is-uppercase}, \ff{to-float}, \ff{swap-case}, and \ff{to-int}. While selecting the functions, we were guided by features such as sufficient quantity for the Turing machine, the algorithm in the "Populating the Set" section, and statistics on GitHub. 
\end{document}