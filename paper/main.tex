\documentclass[11pt,nonacm,natbib=false]{acmart}
\settopmatter{printfolios=false,printccs=false,printacmref=false}
\usepackage[utf8]{inputenc}
\usepackage{paralist}
\usepackage{ffcode}
\usepackage{authblk}
\usepackage{calc}
\usepackage{ifthen}
\usepackage{tikz}

\title{Methods Necessary for String Classes in Object-Oriented Programming Languages}
\author{
Timolai Andrievich, 
 Aksinya Kochunova, 
 Egor Zavrazhnov, \\
 Kseniya Sicheva, 
 Anel Salkenova, 
 Irina Schetinina 
}

\date{7 June 2022}

\affil{Innopolis University}

\begin{document}

\maketitle

\section{Introduction}
In programming, a string is a primitive type designed to provide an interface for an ordered set of characters. However, standard library implementations of this interface vary in different languages. Thus, it is clear that the programming community has not decided on the optimal implementation of a string class. Therefore, this paper aims to determine a minimalistic set of string functions sufficient for a string class.

\section{Set Building}
\subsection{Necessary and Sufficient Functions}
The memory tape of the Turing machine can be represented as three strings: parts of the memory tape right and left from the pointer and the memory cell with the pointer. Three operations are necessary for a Turing machine: move the head to the left, move the head to the right, and write a symbol to the cell. Therefore, the following methods are necessary:
\begin{inparaenum}
    \item concatenate---concatenate two strings
    \item substring---returns the substring of requested length, starting at a given position as a string
    \item length---returns the length of the string
\end{inparaenum}
It is easy to see that these methods are sufficient to implement Turing machine commands. Therefore, all computable algorithms, including string-related algorithms, can be described through strings. Because standard libraries include regular expressions, function regex---split string into groups according to regular expression pattern.
\subsection{Populating the Set}
However, such an approach is not practical, and other methods need to be  included. For this purpose, the following algorithm for set construction is proposed:
\begin{enumerate}
    \item Functions char-at, regex, and concatenate are added to the set
    \item The function that is 
        \begin{inparaenum}
            \item Can not be implemented in three or fewer instructions using functions already in set
            \item Can be implemented in the least amount of instructions among all remaining functions
        \end{inparaenum}
        is added to the set
    \item The second step is repeated until no fitting functions remain
    \item Then, the set is hedged by deleting functions that do not fit requirements outlined in step two
\end{enumerate}
\subsection{Analysis of the final selected functions}
After executing the algorithm, following functions were selected:
\begin{inparaenum}
    \item concatenate---concatenates two strings
    \item substring---returns substring specified by arguments
    \item compare---compares two strings
    \item capitalize---converts the first character to the uppercase, and all other to the lowercase
    \item format---returns formatted string
    \item hash---returns the hash of the string
    \item is-alphabetic---checks if the string contains only letters
    \item is-lowercase---checks if the string contains only lowercase letters
    \item is-uppercase---checks if the string contains only uppercase letters
    \item swap-case---converts all lowercase characters to uppercase, and vise versa
    \item to-float---converts string to float
    \item to-int---converts string to integer
\end{inparaenum}

\subsection{Functions in other languages}
Libraries in different languages have different specifics. The most complete are the Java and Python language libraries. Libraries contain almost all the functions collected in the common table of 4 libraries. They are missing only the most specific of all the assembled functions. Because of this, they may have redundant functions that have one result. C++ library is the most minimalistic. Perhaps this is due to its age, because the language appeared almost 10 years earlier than the others in the selection. It lacks some common functions, but has a few unusual ones, mostly memory-related. For example, capacity - this function for strings is not available in Java, Python or Ruby. Ruby has the most balanced library. It has many features but almost no repetitive features like Java. This is because both Python and C++ have influenced the language.
The main information support is statistics collected from various libraries.  It can be used to calculate the importance of a function from the frequency of its use by other programmers. The choice is also based on the alogrithm from part 2.2. Every language has functions not added to the EO language library:
\begin{table}[H]
\begin{tabular}{l | l | p{265pt}}
Function name & Libraries          & Reasons of excluding                                                                                                                      \\
capacity      & C++                & Presented only in one library, has limited functionality, used only in 0,02\% of general string functions usage                           \\
fill-letft    & Ruby               & Presented only in one library, can be implemented in three or fewer instructions, used only in 0,002\% of general string functions usage  \\
fill-right    & Ruby               & Presented only in one library, can be implemented in three or fewer instructions, used only in 0,002\% of general string functions usage  \\
is-title      & Python             & Presented only in one library, can be implemented in three or fewer instructions, used only in 0,0001\% of general string functions usage \\
repeat        & Java, Python       & Presented only in 2 libraries, can be implemented in three or fewer instructions, used only in 0,002\% of general string functions usage  \\
patrition     & Python, Ruby       & Presented only in 2 libraries, used only in 0,003\% of general string functions usage                                                     \\
shrink-to-fit & C++                & Presented only in one library, has limited functionality, used only in 0,003\% of general string functions usage                          \\
strip         & Java, Python, Ruby & Can be implemented in three or fewer instructions, used only in 0,015\% of general string functions usage                                 \\
starts-with   & Java, Python, Ruby & Can be implemented in three or fewer instructions, used only in 0,01\% of general string functions usage                                 
\end{tabular}
\end{table}

\subsection{StringBuilder implementation}
\begin{inparaenum}
After discussing the details of the implementation of the functions, we pointed out that the focus was not on the efficiency of the functions, but purely on their availability and usability. Therefore it was decided at this stage of development to remove the implementation of the StringBuilder class from the general task list and to implement functions without efficient development. In the future, it may be possible to refine these functions with the addition of effective use by implementing the StringBuilder.
\end{inparaenum}
   
\subsection{GitHub analysis}
\begin{inparaenum}
The team analyzed the libraries of several languages: Ruby, C++, Java, and Python. The data was collected from GitHub with an advanced search among all the code. The result was a list of the most popular functions for each language involved. Some of the most popular functions have already been implemented, as well as functions related to regular expressions. In C++, the selected functions cover 76\% of the uses of functions with strings in general. In Python this number is 44\%, Ruby - 33\%, Java - 38\%. The small percentage in the last three languages can be explained by a large number of redundant functions in that language.
\end{inparaenum}


\section{Conclusion}
Therefore, after analyzing the selection of functions, we chose several: concatenate, substring, compare, capitalize, format, hash, is-alphabetic, is-lowercase, is-uppercase, to-float, swap-case, and to-int. In selecting the functions, we were guided by features such as sufficient quantity for the Turing machine, the algorithm in the "Populating the Set" section, and statistics on GitHub. 
\end{document}
