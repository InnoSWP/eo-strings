\documentclass[11pt,nonacm,natbib=false]{acmart}
\settopmatter{printfolios=false,printccs=false,printacmref=false}
\usepackage[utf8]{inputenc}
\usepackage{paralist}
\usepackage{ffcode}
\usepackage{authblk}
\usepackage{calc}
\usepackage{ifthen}
\usepackage{tikz}

\title{Methods Necessary for String Classes in Object-Oriented Programming Languages}
\author{
Timolai Andrievich, 
 Aksinya Kochunova, 
 Egor Zavrazhnov, \\
 Kseniya Sicheva, 
 Anel Salkenova, 
 Irina Schetinina 
}

\date{7 June 2022}

\affil{Innopolis University}

\begin{document}

\maketitle

\section{Introduction}
In programming, a string is a primitive type designed to provide an interface for an ordered set of characters. However, standard library implementations of this interface vary in different languages. Thus, it is clear that the programming community has not decided on the optimal implementation of a string class. Therefore, this paper aims to determine a minimalistic set of string functions sufficient for a string class.

\section{Set Building}
\subsection{Necessary and Sufficient Functions}
The memory tape of the Turing machine can be represented as three strings: parts of the memory tape right and left from the pointer and the memory cell with the pointer. Three operations are necessary for a Turing machine: move the head to the left, move the head to the right, and write a symbol to the cell. Therefore, the following methods are necessary:
\begin{inparaenum}
    \item concatenate---concatenate two strings
    \item substring---returns the substring of requested length, starting at a given position as a string
    \item length---returns the length of the string
\end{inparaenum}
It is easy to see that these methods are sufficient to implement Turing machine commands. Therefore, all computable algorithms, including string-related algorithms, can be described through strings. Because standard libraries include regular expressions, function regex---split string into groups according to regular expression pattern.
\subsection{Populating the Set}
However, such an approach is not practical, and other methods need to be  included. For this purpose, the following algorithm for set construction is proposed:
\begin{enumerate}
    \item Functions char-at, regex, and concatenate are added to the set
    \item The function that is 
        \begin{inparaenum}
            \item Can not be implemented in three or fewer instructions using functions already in set
            \item Can be implemented in the least amount of instructions among all remaining functions
        \end{inparaenum}
        is added to the set
    \item The second step is repeated until no fitting functions remain
    \item Then, the set is hedged by deleting functions that do not fit requirements outlined in step two
\end{enumerate}
\subsection{Analysis of the final selected functions}
After executing the algorithm, following functions were selected:
\begin{inparaenum}
    \item concatenate---concatenates two strings
    \item substring---returns substring specified by arguments
    \item compare---compares two strings
    \item capitalize---converts the first character to the uppercase, and all other to the lowercase
    \item format---returns formatted string
    \item hash---returns the hash of the string
    \item is-alphabetic---checks if the string contains only letters
    \item is-lowercase---checks if the string contains only lowercase letters
    \item is-uppercase---checks if the string contains only uppercase letters
    \item swap-case---converts all lowercase characters to uppercase, and vise versa
    \item to-float---converts string to float
    \item to-int---converts string to integer
\end{inparaenum}

\subsection{Functions in other languages}
A proper library is written with the experience of other languages in mind to avoid common mistakes. All the languages analyzed in this article have functions with different names but with the same result. It's called pizza language. Many libraries have a lot of functions that are rarely used. Either no one knows about them, or the result can be obtained in a more complicated way with a more popular function. This cannot be avoided in industrial and old languages, but the EO language has a strong academic foundation. An important task is to keep the purity and elegance of the language. 
Every language has functions not added to the EO language library. There may be several reasons: they are present in the library of only one language, or they are redundant. 
\begin{table}[]
\begin{tabular}{ l | l | p{265pt}}
Function name & Libraries          & Reasons of excluding                                                             \\
capacity      & C++                & Presented only in one library, has limited functionality                         \\
fill-left    & Ruby               & Presented only in one library, not so important right now                        \\
fill-right    & Ruby               & Presented only in one library, not so important right now                        \\
is-title      & Python             & Presented only in one library, can be implemented in three or fewer instructions \\
repeat        & Java, Python       & Can be implemented in three or fewer instructions, 2 libraries                   \\
patrition     & Python, Ruby       & 2 libraries, not so important right now,                                         \\
shrink-to-fit & C++                & Presented only in one library, not so important right now                        \\
strip         & Java, Python, Ruby & Can be implemented in three or fewer instructions, not so important right now    \\
starts-with   & Java, Python, Ruby & Can be implemented in three or fewer instructions, not so important right now   
\end{tabular}
\end{table}

\subsection{StringBuilder implementation}
\begin{inparaenum}
After discussing the details of the implementation of the functions, we pointed out that the focus was not on the efficiency of the functions, but purely on their availability and usability. Therefore it was decided at this stage of development to remove the implementation of the StringBuilder class from the general task list and to implement functions without efficient development. In the future, it may be possible to refine these functions with the addition of effective use by implementing the StringBuilder.
\end{inparaenum}
   
\subsection{GitHub analysis}
\begin{inparaenum}
The team analyzed the libraries of several languages: Ruby, C++, Java, and Python. The data was collected from GitHub with an advanced search among all the code. The result was a list of the most popular functions for each language involved. Some of the most popular functions have already been implemented, as well as functions related to regular expressions. In C++, the selected functions cover 76\% of the uses of functions with strings in general. In Python this number is 44\%, Ruby - 33\%, Java - 38\%. The small percentage in the last three languages can be explained by a large number of redundant functions in that language.
\end{inparaenum}


\section{Conclusion}
Therefore, after analyzing the selection of functions, we chose several: concatenate, substring, compare, capitalize, format, hash, is-alphabetic, is-lowercase, is-uppercase, to-float, swap-case, and to-int. In selecting the functions, we were guided by features such as sufficient quantity for the Turing machine, the algorithm in the "Populating the Set" section, and statistics on GitHub. 
\end{document}
